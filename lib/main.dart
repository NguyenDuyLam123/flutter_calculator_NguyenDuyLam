import 'package:flutter/material.dart';

// LAB 2 - Simple Mobile Calculator
// main.dart
// Author: generated by ChatGPT (for student lab)
// Comments included to explain logic and structure.

void main() {
  runApp(const CalculatorApp());
}

class CalculatorApp extends StatelessWidget {
  const CalculatorApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Simple Calculator',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        // Figma colors: Primary (#2D3142), Secondary (#4F5D75), Accent (#EF8354)
        primaryColor: const Color(0xFF2D3142),
        scaffoldBackgroundColor: const Color(0xFFF5F6FA),
        // Roboto is default on Android; set baseline text theme
        textTheme: const TextTheme(
          bodyLarge: TextStyle(fontFamily: 'Roboto'),
          bodyMedium: TextStyle(fontFamily: 'Roboto'),
        ),
      ),
      home: const CalculatorScreen(),
    );
  }
}

class CalculatorScreen extends StatefulWidget {
  const CalculatorScreen({super.key});

  @override
  State<CalculatorScreen> createState() => _CalculatorScreenState();
}

class _CalculatorScreenState extends State<CalculatorScreen> {
  // State variables described in PDF
  String _display = '0';
  String _equation = '';
  double _num1 = 0;
  double _num2 = 0;
  String _operation = '';

  // Limit display length to avoid overflow
  final int _maxDisplayLength = 18;

  // Button definitions in order (for grid)
  final List<String> buttons = [
    'C', 'CE', '%', '÷',
    '7', '8', '9', '×',
    '4', '5', '6', '-',
    '1', '2', '3', '+',
    '±', '0', '.', '=',
  ];

  // Helper to handle numeric input
  void _inputDigit(String digit) {
    setState(() {
      if (_display == 'Error') {
        // If previous was error, reset on digit
        _display = '0';
      }
      if (_display == '0' && digit != '.') {
        _display = digit;
      } else {
        // Avoid too long numbers
        if (_display.length < _maxDisplayLength) {
          _display += digit;
        }
      }
    });
  }

  // Decimal point
  void _inputDecimal() {
    setState(() {
      if (_display == 'Error') {
        _display = '0';
      }
      if (!_display.contains('.')) {
        _display += '.';
      }
    });
  }

  // Toggle plus/minus
  void _toggleSign() {
    setState(() {
      if (_display == 'Error') return;
      if (_display.startsWith('-')) {
        _display = _display.substring(1);
      } else if (_display != '0') {
        _display = '-$_display';
      }
    });
  }

  // Percent: current number / 100
  void _percent() {
    setState(() {
      if (_display == 'Error') return;
      try {
        final val = double.parse(_display);
        final res = val / 100;
        _display = _formatResult(res);
      } catch (e) {
        _display = 'Error';
      }
    });
  }

  // Clear all
  void _clearAll() {
    setState(() {
      _display = '0';
      _equation = '';
      _num1 = 0;
      _num2 = 0;
      _operation = '';
    });
  }

  // Clear end (backspace)
  void _clearEnd() {
    setState(() {
      if (_display == 'Error') {
        _display = '0';
        return;
      }
      if (_display.length <= 1) {
        _display = '0';
      } else {
        _display = _display.substring(0, _display.length - 1);
        // handle lone "-" (e.g., "-3" -> -)
        if (_display == '-' || _display == '-0') {
          _display = '0';
        }
      }
    });
  }

  // When pressing an operation (+ - × ÷)
  void _setOperation(String op) {
    setState(() {
      if (_display == 'Error') return;

      // If there is already an operation and user pressed a new one
      // compute immediate result (left-to-right), like many simple calculators.
      try {
        if (_operation.isNotEmpty) {
          // there is pending operation: compute with current display as _num2
          _num2 = double.parse(_display);
          final result = _compute(_num1, _num2, _operation);
          if (result == null) {
            _display = 'Error';
            _equation = '';
            _operation = '';
            _num1 = 0;
            return;
          } else {
            _num1 = result;
            _display = _formatResult(_num1);
          }
        } else {
          // no pending operation, store first operand
          _num1 = double.parse(_display);
        }
      } catch (e) {
        _display = 'Error';
        _operation = '';
        _equation = '';
        return;
      }

      // set new operation and reset display for next operand
      _operation = op;
      _equation = '${_formatResult(_num1)} $op';
      _display = '0';
    });
  }

  // Equals pressed
  void _equals() {
    setState(() {
      if (_display == 'Error') return;
      if (_operation.isEmpty) {
        // Nothing to compute
        return;
      }
      try {
        _num2 = double.parse(_display);
      } catch (e) {
        _display = 'Error';
        return;
      }

      final result = _compute(_num1, _num2, _operation);
      if (result == null) {
        // Error, e.g., division by zero
        _display = 'Error';
        _equation = '';
        _operation = '';
        _num1 = 0;
        _num2 = 0;
      } else {
        _display = _formatResult(result);
        _equation = '${_formatResult(_num1)} $_operation ${_formatResult(_num2)} =';
        // After equals, allow chaining: result becomes new num1; clear operation
        _num1 = result;
        _operation = '';
      }
    });
  }

  // Actual computation; returns null if error (e.g., division by zero)
  double? _compute(double a, double b, String op) {
    switch (op) {
      case '+':
        return a + b;
      case '-':
        return a - b;
      case '×':
        return a * b;
      case '÷':
        if (b == 0) return null;
        return a / b;
      default:
        return null;
    }
  }

  // Format result: remove trailing .0 when integer and limit length
  String _formatResult(double val) {
    // If very large/small, use toStringAsPrecision?
    // But keep simple: if integer -> no decimals
    if (val.isInfinite || val.isNaN) {
      return 'Error';
    }
    if (val == val.roundToDouble()) {
      final s = val.toInt().toString();
      return _trimLength(s);
    } else {
      String s = val.toString();
      // Avoid long double strings; limit to 10 decimal places and trim trailing zeros
      if (s.contains('e')) {
        // scientific notation - keep as is but trimmed
        return _trimLength(s);
      }
      double rounded = double.parse(val.toStringAsFixed(10));
      s = rounded.toString();
      // trim trailing zeros and possible trailing dot
      s = s.replaceFirst(RegExp(r'\.?0+$'), '');
      return _trimLength(s);
    }
  }

  // Trim string length to _maxDisplayLength, if too long, show last part (like calculators)
  String _trimLength(String s) {
    if (s.length <= _maxDisplayLength) return s;
    // Prefer scientific format for very long numbers
    return s.substring(0, _maxDisplayLength);
  }

  // Main handler when a button is pressed
  void _onButtonPressed(String value) {
    if ('0123456789'.contains(value)) {
      _inputDigit(value);
      return;
    }
    switch (value) {
      case '.':
        _inputDecimal();
        break;
      case 'C':
        _clearAll();
        break;
      case 'CE':
        _clearEnd();
        break;
      case '±':
        _toggleSign();
        break;
      case '%':
        _percent();
        break;
      case '+':
      case '-':
      case '×':
      case '÷':
        _setOperation(value);
        break;
      case '=':
        _equals();
        break;
      default:
        break;
    }
  }

  // Build calculator UI
  @override
  Widget build(BuildContext context) {
    const primary = Color(0xFF2D3142);
    const secondary = Color(0xFF4F5D75);
    const accent = Color(0xFFEF8354);

    return Scaffold(
      body: SafeArea(
        minimum: const EdgeInsets.all(20.0), // Screen padding 20px (Figma)
        child: Column(
          children: [
            // Display area
            Expanded(
              flex: 3,
              child: Container(
                width: double.infinity,
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                  boxShadow: const [
                    BoxShadow(
                      color: Colors.black12,
                      blurRadius: 8,
                      offset: Offset(0, 4),
                    )
                  ],
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // Equation (small)
                    Text(
                      _equation,
                      style: const TextStyle(
                        fontSize: 16,
                        color: Colors.black54,
                      ),
                    ),
                    // Display value - scrollable if long
                    Expanded(
                      child: Align(
                        alignment: Alignment.bottomRight,
                        child: SingleChildScrollView(
                          reverse: true,
                          scrollDirection: Axis.horizontal,
                          child: Text(
                            _display,
                            maxLines: 1,
                            style: const TextStyle(
                              fontSize: 36, // result should be larger (24px Medium in spec)
                              fontWeight: FontWeight.w500,
                              fontFamily: 'Roboto',
                              color: Color(0xFF2D3142),
                            ),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),

            const SizedBox(height: 20),

            // Button grid
            Expanded(
              flex: 7,
              child: GridView.builder(
                physics: const NeverScrollableScrollPhysics(),
                itemCount: buttons.length,
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 4,
                  mainAxisSpacing: 16, // Button spacing 16px
                  crossAxisSpacing: 16,
                  childAspectRatio: 1.1,
                ),
                itemBuilder: (context, index) {
                  final b = buttons[index];
                  // determine button color
                  Color bgColor = Colors.white;
                  Color textColor = const Color(0xFF2D3142);
                  double fontSize = 20;

                  if (b == 'C' || b == 'CE') {
                    bgColor = Colors.white;
                    textColor = const Color(0xFF2D3142);
                  } else if (b == '÷' || b == '×' || b == '-' || b == '+' || b == '=') {
                    bgColor = accent;
                    textColor = Colors.white;
                    fontSize = 22;
                  } else if (b == '%' || b == '±') {
                    bgColor = Colors.white;
                    textColor = const Color(0xFF4F5D75);
                  } else {
                    // number buttons
                    bgColor = Colors.white;
                    textColor = const Color(0xFF2D3142);
                  }

                  // Make '=' button slightly larger visually via aspect ratio; handled in grid
                  return CalcButton(
                    text: b,
                    backgroundColor: bgColor,
                    textColor: textColor,
                    borderRadius: 12, // border radius 12px
                    onTap: () => _onButtonPressed(b),
                    fontSize: fontSize,
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Reusable calculator button widget
class CalcButton extends StatelessWidget {
  final String text;
  final Color backgroundColor;
  final Color textColor;
  final double borderRadius;
  final VoidCallback onTap;
  final double fontSize;

  const CalcButton({
    super.key,
    required this.text,
    required this.backgroundColor,
    required this.textColor,
    required this.borderRadius,
    required this.onTap,
    this.fontSize = 18,
  });

  @override
  Widget build(BuildContext context) {
    // Use InkWell for tap animation
    return Material(
      color: backgroundColor,
      borderRadius: BorderRadius.circular(borderRadius),
      child: InkWell(
        borderRadius: BorderRadius.circular(borderRadius),
        onTap: onTap,
        child: Container(
          alignment: Alignment.center,
          child: Text(
            text,
            style: TextStyle(
              color: textColor,
              fontSize: fontSize,
              fontWeight: text == '=' ? FontWeight.w600 : FontWeight.w500,
            ),
          ),
        ),
      ),
    );
  }
}
